---
layout: post
title: "컴퓨터 네트워크"
date: 2025-04-07
---

### Layer와 Layered 구조 

계층적 요소가 의미하는 바? : 요소 간 관계 표현 

- 설계 : 시스템을 이루는 요소 정의, 요소 간 관계 정의 

- Layered : 4층은 3층에 의존적이다 → 행위, 기능에 대해 의존적 (4는 3이 없으면 성립X = 존립의존) 

	- 의존관계가 직렬적으로 성립할 때 ⇒ Layered 구조 = 존립이 의존적이구나 

	- 4는 3을 전제, = 4가 존재하기 위해선 3이 전제됨 

- OSI 7 Layer와 관련. 

<br/>

### 네트워크와 네트워킹 그리고 개념 

네트워크 = 관계 

네트워킹 = 상호작용

<br/>

<< 예시 설명 >> 

철수와 올리비아가 <<상호작용>> 을 하고 싶다면? 

[ 언어적 문제가 해결되어야 함 << 말을 해야 함 << 2m 내에 같이 있어야 함 ] ← 계층적 구조

의존적 관계가 성립하는 프로토콜 즉, 규칙을 계층 구조로 나열한게 OSI 7 Layer 

<br/>

**개념과 구현**

연예인(개념) ← 박은빈(구현) ⇒ 상속 관계 

TCP/IP는 구현에 해당함 

<br/>

### User mode와 Kernel mode

[//]: # (column_list is not supported)

	[//]: # (column is not supported)

		![스크린샷_2025-04-07_103433.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/83a69d8f-6be2-4385-96df-7c58b0b2f3bf/7a902203-bc83-42de-8037-77f182a1ae53/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-04-07_103433.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4665XN7AOYP%2F20251225%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251225T155316Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHYaCXVzLXdlc3QtMiJGMEQCIBxG8J7o98MnZUERbKn6v7Bfsv9f2JlQ08M9SgnQOKHIAiBk4wOBCmEulOFo72y5r%2FNcdI%2B1zAedzNrhywcDnJr3Cir%2FAwg%2FEAAaDDYzNzQyMzE4MzgwNSIMgJwGRnlxoGSDhIKsKtwD5OEzUfrQZEHaB9PNDifw30pEhm3nlTWRLLiQZliCQQzHNvCM%2Bz923bXtJ7%2Brx9FNwdlFiGQAh%2BsQMt3%2BNiQ6i1krwfn5YfnRBuQ2FiS54Wwz96qQBAsHlT8o9y5EQIAUq9EVeFEDdh2ox%2F3lH3Dll79F4tojeDi%2B%2BcuCEGbSDElvDZ2PcqXpXuONUWQSuQWS9Gv8OZp65xhC6BeISSU0ebCqxtQp8yIjBObjjt4h0CZrdVk7GZynOP4BlcBvs5VPMQ2rrZzTfvCHhA7P4W%2F7pJie4d5DFf%2Fl8SJSNrio2sxqoi0EcOmn601hcme21g5yiBj4ktSWrU88yLVfCQjaTKD1EL4U46XoAhWl2A959lb%2Fvo%2BxmeWOKktaDt92jaC6KbqawXGL%2BrkaPinkHs0VBwMzTE5juxMR%2BjcaDnwKZkWmeha2yug3fIKaWhdTNwb9jiWxOYAkNpqWgK%2BkQtCn7XZZx4vP4chdRltM3glJow0QqC2kUSLq9yiE%2B5XxkUe28rQ1uMnyAbxFdSHMkhO6fR1Pc92aiNfilMAu88IotxNqyIY%2FLIUoL5WTYclQsL7I9va26w8p9qkFhl2FQC4xFmk83OEgd2sVRem7qvRcEnlob2%2Fa8eW6N9Ajgi4wuI21ygY6pgHZHEKk%2F6BbhkdmNBFHe8yOrp9uJESCbtEJFtREQ5kdV%2Fq8MvqRrJBYgHKbPWb5zyy05ZI8GYZgk%2FSw0KzVknW9eTPFi09PVFLja2j5%2Ful6psECOPyNsGQkOw51cjHAOOiy2UUsjBG4jNePI4A4e3IIEk4fxZ0%2Bo6tFxtEep3nw8OsAauS3E%2B%2FLYDbmzrfbDm2VM5olVB4k%2BRQrTqkMzKeDY7jDl1gF&X-Amz-Signature=dc76aff207eaf5b5e7171768f93737352f9ec638f2ec716a00fa9a01e1571613&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)

	[//]: # (column is not supported)

		컴퓨터 = S/W +  H/W

		S/W = User mode + Kernel mode

		Driver : 하드웨어를 제어하기 위한 소프트웨어 , 랜 카드는 드라이버에 의해 작동

		Socket : TCP/IP를 추상화시킨 인터페이스 파일

		전송계층 = TCP / 네트워크 계층 = IP
 

		Driver / NIC(랜카드) = Data Link ~ Physical 

		L5 이상 = User mode application (프로세스 수준으로 설명 가능, 프로그램이 갖는 특징)

		<br/>

<br/>

### OSI 7 Layer와 식별자 

L2 = 데이터링크 → 이더넷 = 유선 네트워크 

네트워크 = 인터넷 

TCP, UDP (L4)

L5 = SSL(TLS)

L7 = HTTP 프로토콜 

<br/>

<u>**식별자**</u>** **

L2 : **MAC **주소가 식별자 (physical address → **랜 **카드(NIC)를 식별) 

L3 : **IP**주소 → 인터넷을 사용하는 컴퓨터 즉, **host**에 대한 식별자

**Port **번호 → 인터페이스(L2), 서비스(L3/L4), 프로세스

<br/>

> ipconfig /all  → 컴퓨터 정보 

- 물리적 주소 = MAC address → 48 bit (16진수) 

- IPv4 주소

<br/>

### Host? 

컴퓨터 = Pc,  스마트폰

Host = **인터넷에 연결된 컴퓨터 **

**Host **= End point + Switch 

- **switch **: 네트워크 그 자체를 이루는 호스트 ⇒ IP 주소가 붙는 무언가.. = 인프라 

	- Router, IPS, Tab, Aggregation 

- **End point** : 네트워크 이용 주체 → 네트워크라는 인프라 structure를 써먹는 것. → 단말기

	- Client , Server, Peer

<br/>

### 스위치가 하는 일과 비용 

네트워크 → 고속도로망 = 인터넷

- 교차로 = 스위치

- 경로 선택 = 인터페이스를 선택 = 스위칭 

- 자동차 = Packet 

- **IP** 주소를 근거로 스위칭 했다면 = **L3 Switching** (네트워크가 L3)

	- **L3 Switch = Router** → 이정표 들어있음 = **라우팅 테이블** → 목적지 주소에 따른 **이정표 **

- 스위칭 할 때, **MAC **주소로 한다면? → L2 주소 → **L2 Switching **

- **Port** 번호로 Switching → **L4 **Switch

- **HTTP** : **L7** Switch 

<br/>

**비용** → Matric 값 

<br/>

### NIC, L2 Frame, LAN 카드 그리고 MAC 주소 

- NIC = Network Interface Card 

	- NIC은 하드웨어이며, MAC 주소(NIC 식별자) 가짐 

- LAN = Local Area Network , 네트워크의 가장 작은 규모 

	- 공유기에 우리집 기기가 연결되어 있음 = 하나의 LAN 

- Packet : L2에서 언급하는 인터넷에서의 단위 

- L2 수준에서의 단위 = Frame 

	- 네트워크 환경에서 유통되는 단위 즉, 데이터 단위 

	- 속도 1G**b**ps → bit

<br/>

### L2 스위치? 

- L2 Access Switch : End Point(단말기)와 직접 연결되는 스위치 

- MAC 주소를 근거로 스위칭 ← L2 이므로

- 단자 하나 = interface = port 

- Link-up : 연결이 잘 되었다. 

- Link-down : 연결 불량

- Up Link : L2 Access Switch를 건너 L3로 나아갔을 떄 그 링크 

<br/>

**L2 Distribution switch** : L2 Access 스위치를 위한 스위치 

![스크린샷_2025-04-07_113240.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/83a69d8f-6be2-4385-96df-7c58b0b2f3bf/de55907a-1293-42de-b419-7bb620e43824/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7_2025-04-07_113240.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=ASIAZI2LB4664EV47OC7%2F20251225%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20251225T155313Z&X-Amz-Expires=3600&X-Amz-Security-Token=IQoJb3JpZ2luX2VjEHYaCXVzLXdlc3QtMiJHMEUCIQCeRbTxY0RgqHLyKGHgLXv7Lqp3Noj%2FkA9JvQmlVNivgQIgNm%2Bvm0PGZ449ouXatrMyFgv1pIrDMzr8Ch7VuGeHkcAq%2FwMIPxAAGgw2Mzc0MjMxODM4MDUiDCFgvubOyiRVsuWTSSrcA7xnLdO73umL43CMTVCXfTk%2F3CCmqW%2F7BSj59pqVFeYjnstRfBx9WDaLRwUUcvQToMAizvyJgx%2FMQ0UW5EnzyiRrzsJa6gOZ7Lrun5cDLuXtIpx3syXaT1Ch35BO3vKoEWnVboej%2FGYoHhnn48%2Bc8PdViPetwaONeQ0WO%2F1fu0WortX1Gi5Cg8eoGCE0%2BBSjODZmJdYTt%2FRk2%2B7nQEpt9kGsRLA4tNrRdg57j%2FHptFz6FylgejsMdRKzaLDebk%2F7wk7k8RNYB0P8SHLOE0PdX50C7oVNzDf8UxljurJqJP1nCdhKLQTePaaCog9Or4500ylsvgW6zA8N0eopUxDN6cnlB5bk04ydLjFfr9hNR3EdWDc3Y0f84F8kNK%2FMEiGXT%2F2vc%2FzoDqkA7%2BmzdMjFRtyfjVAJcBoTpnhfBP%2FvmUe01UzSUAT9ISasfkYi1zo6%2FpQ9KyJz2dMzrFYZ8rt1dHvWg3e8gX0vhxYpyjWQmDuVkq0W8v0rTr1K73RHzpRI%2FiOlEK4AGxfyn%2FpcRzlaBFc18MuSox51%2F17M4uza%2Bsfp%2F5iDIMSBLqzwfUfx6Shm%2BNxk0U7WXmu5lmggj5GKg0ROWS6HPj1FijIEKF4Tq4OizywCZrcsWsT7T5DkMNSNtcoGOqUB46IeLqr8cal4E14jZW96jPZY7nCqjwuL%2BqVgZ%2BENxAMZB8pv0RekcFTUCizw15hY%2FxOX%2B2t6EqsCu7iNH9zNf5Y9fn7jkyQ4CG3BI1RCpOKxSWqSo%2BSMd4ofXcJ6J9oRIfmxwV1Q915Bd0XOG7HanJ%2F9SLcq5zMBa9Q5pAnFDkHt1cEdC6iLnHoP912TCTLDK7ugdAe4WExb4vc3uxskUkhQD4vA&X-Amz-Signature=3b5940dc6e554224323871a2209470009c349967602dd31a02e2a59cf55a551e&X-Amz-SignedHeaders=host&x-amz-checksum-mode=ENABLED&x-id=GetObject)

- L2 Access를 모아서 스위칭 함. 

- L2는 단말기랑 직접 붙음 

- Router : 건물 당 하나

- L2 Distribution Switch : 한 층에 하나 

- L2 Access Switch : 사무실 당 하나 

<br/>

### LAN과 WAN의 경계 그리고 Broadcast

브로드캐스트 : 방송 

	- Broadcast(동네방네) ↔ Unicast(한 곳에)

	- Broadcast 주소 : 이진수로 모두 1

		- ex. MAC → FF-FF-FF-FF-FF-FF (48 bit 전체가 1로 채워지면 방송주소)

	- 출발지 / 목적지 주소 → 목적지 주소가 Broadcase : 전부 다 받아라 

	- Broadcasting이 끝날 때 까지 다른 컴퓨터들은 통신 불가 → Broadcase 최소화해야 함

	- LAN에서 보내는 데이터 단위 = Frame 

		- Header엔 출발지, 목적지 주소 

	<br/>

	**네트워크 규모**

	OSI 7 Layer

	- **L2 : Ethernet → MAC(48 bit)**

	- **L3 : Internet(IP) → IPv4**

	- **L4 : TCP/UDP**

	- **L5: SSL **

	- **L7: HTTP **

**H/W = Physical**

**S/W = Logical**

- L1, L2는 물리적으로 설명

- Internet은 Logical → 논리적 → 실체 없음 → Virtual로 사용하기도 함

- H/W를 S/w로 구현 

	- cpu(=machine)를 sw로 구현 = Virtual Machine

<br/>

<<요령>>

LAN = L1 + L2 → Physical로 설명되는 부분 이라고 이해하자. 

**인터넷 **= WAN , 구현되는 계층이 소프트웨어 계층 → 인터넷은 **논리적 **네트워크

3계층 부터는 소프트웨어적으로 존재하는 논리 네트워크 

물리로 존재 = 선 꽂혔냐,,,

<br/>

### IPv4 주소의 기본 구조 

L2 : 이더넷

L3 : IP → **IPv4 주소 체계 사용 ⇒ 32 bit = 8 bit * 4**

L4 : TCP/UDP

L5 : SSL

L7: HTTP

---

8bit ? 

- 2^8 = 256

- 8비트로 표현 가능한 수의 범위 0~255 

- IP 주소는 8 비트씩 쪼갬 

- 192.168.0.10

	- [1100 0000 / 1010 1000 / 0000 0000] / [0000 1010]

	- [Network ID] / [Host ID]

		- Host : 컴퓨터 

		- IP 주소는 호스트에 대한 식별자 → 인터넷에 연결된 컴퓨터 한 식별하기 위해

		- 인터넷은 ip 주소로 목적지 까지 가야 함 → Network ID 찾아 진입한 뒤에 네트워크에 속한 호스트 찾기 

<br/>

### L3 IP Packet

패킷 = 단위 데이터

- **Header **+ **Payload **

	- Header = 송장, 헤더가 실어나르는 택배 = 페이로드 

- 패킷의 최대 크기는 **MTU **(Maximum transmisstion unit) = **1500 **bytes (작아, 1.4kb)

- 헤더는 출발지, 목적지 정보 

<br/>

### Encapsulation과 Decapsulation 

- Encapsulation : 포장하여 단위화 

	- IP Packet 통째로 L2 Frame의 Payload가 됨

	- L3 IP Packet의 Payload는 L4 TCP Segment가 Payload

	- Segment 안에 계속 L5…. 

- Decapsulation : 포장 해체 

<br/>

### 패킷의 생성과 전달

택배 전송 과정으로 비유.

- Process : 보내는 이 / 받는 이

- Data : 책, 보내는 물건

- Packet : 택배 

- Gateway : 기사님

- Host : 집

- interface : 현관

- 택배를 Routing

- IPv4 목적지 주소를 보고 영희의 집 즉, 호스트로 도착

- 이름(=포트번호)을 보고 호스트 내부에서 프로세스 선택해서 줌 

cf. Socket = 파일의 일종, 유저모드 어플리케이션 프로세스가 접근할 수 있도록 커널 모드 프로토콜을 추상화 한 파일의 일종

<br/>

[Frame | [ IP | [TCP | [Data] ] ] ]

	TCP에서 데이터 앞에 TCP 헤더 붙이기 ⇒ 세그먼트 

	IP 헤더가 또 붙고 드라이버로 가면 Frame 헤더 붙음 (이더넷 헤더) 

	→ 이더넷 헤더인 채로 나가게 됨 

	Access Switch 만나서 라우터 게이트 웨이 만나서 인터넷으로 나가는 구조 

<br/>

### 계층 별 데이터 단위 

**단위** (암기) 

- 크롬 브라우저가 인터넷으로 데이터 송수신 할 때.

	- **L1~L2 : Frame **

	- **L3(IP) : Packet (MTU=1500 bytes)**

	- **L4(TCP) : Segment (MSS=1460bytes)**

	---

	- **소켓 수준 : Stream **

		- 시작은 있지만, 끝은 모름. 어플리케이션 수준에서 정하므로, 데이터 송수신하는 운영체제 입장에선 스트림은 연속적으로 이어진 크기를 모르는 큰 데이터

- **IP**에선 데이터 단위 정해져 있음. **MTU**

- **Segment**에선 **MSS**(Maximum Segment Size) 1460 bytes

- Stream 전체가 4mb라면, 최대 패킷 크기 넘어가니까 스트림을 잘라서 분할

- 세그먼트화 될 때 분할 발생 = segmentation 

- stream 이라는 연속적 긴 데이터 자르기 

- 유저모드 어플리케이션은 **소켓**(**스트림=데이터 덩어리 그 자체**) 

cf. datagram : UDP 프로토콜. 패킷과 유사. 데이터 덩어리 

<br/>

### TCP/IP 송수신 구조

**에펠탑을 택배로 보내기**

1. 에펠탑 분해 → 크기 줄이기 → 박스 안에 들어갈 정도로 (MTU 이하로)  → Packet!

1. 운송

1. 조립

분해는 송신 측, 조립은 수신 측

흐름 → TCP/IP

<br/>

패킷의 MTU는 1.4kb 정도 → 파일 하나를 인터넷에서 다운받는다고 하면, MTU에 맞게 쪼개 

TCP : 연결지향

<br/>

<< 발신 서버 >> 

1. 프로세스에 있는 버퍼로 보낼 데이터를 복사해 옴

1. Socket의 I/O 버퍼에 보냄

1. L4 TCP로 가는 순간에 Segmentation이 발생하면서 연결되어 있던 통 데이터가 잘림 → 하나의 퍼즐 조각

1. L3 IP로 내려가면 퍼즐을 박스에 포장함 = Packet 

1. Driver L2로 내려가서 나감 → 택배를 옮기는 트럭이 Frame 

	- Frame은 수시로 변경됨. 트럭을 갈아 탈 수 있음.

<br/>

<< 수신 >> 

1. Frame(트럭)에서 택배 박스 내리기 (L2 수준) 

1. IP에 패킷 전달 (이 시점에 Frame 소멸)

1. 박스 열어서 내용물 갖고, 박스 버리기 (L4, 세그먼트) 

1. Socket I/O 버퍼에 꺼낸 알맹이를 넣기 

	- 운영체제의 TCP 스택에서 수행

	- 프로세스에도 버퍼 존재함 → socket i/o buffer에서 꺼내와 = Recv 

	- Recv는 프로세스의 버퍼 크기대로 recv 시도 

	- 네트워크는 소켓 버퍼에 채우고, 프로세스는 소켓 버퍼에서 가져와 

**TCP는 받은 측이 보낸 측에 ACK 보낼 때 버퍼의 여유공간을 같이 보냄 → 여유 있어야 데이터 보냄 **

<br/>

송신은 EnCapsulation / 수신은 DeCapsulation 

<br/>

**TCP 통신 시 Network 장애 유형**

1. Loss : 유실

1. Retransmission : 보낸 애가 다시 똑같은거 보냄 → 간발의 차로 ACK를 같이 보내 ⇒ 1, 2를 보냈는데 ACK가 안와서 1, 2를 다시 보내 → ACK 3을 보냈는데 왜 1, 2 다시왔지 

	→ 중복 전송 

1. Out of Order : 순서 맞지 않아 → TCP 스택에서 보정이 일어남

1. Zero window : 여유공간 없음 (수신 측 버퍼) 

	- 여유 공간 메모리 크기 = 윈도우 사이즈 

	- 네트워크는 버퍼를 채우고 있는데, 프로세스가 비우질 못함 → 소켓 버퍼가 FULL 

	- 네트워크의 송수신 속도가 프로세스가 비워내는 처리 속도보다 빠름 

	- 꽉 찬 상태에선 수신할 방법이 없음. 여유공간이 없어서

	- End point에서 application이 처리를 빠르게 못해 

<br/>

### IP 헤더 형식 

패킷 : MTU 크기, 헤더+페이로드 

	- 헤더 : 20bytes 가량

	- 32bit 중 8bit = Version, IHL

		- Version : IPv4→ 4

		- IHL : 인터넷 헤더 길이 , 보통 20 bytes

	- 그 뒤 8bit는 Type Of Service (TOS)

	- 그 뒤 16bit는 Total Length : Payload를 의미 → 나올 수 있는 경우의 수 = $ 2^{16} $ ⇒ 64KB

<br/>

**단편화**

- 패킷 자르기 

- TTL : 이 값이 0이면 패킷은 없어진다. 

- Protocol : L3 IP 안의 페이로드 안에 또 다른 헤더가 있을 수 있는데, 이걸 어떻게 해석할지 설명되어 있음 

	- TCP가 보통일텐데, 이 프로토콜 값이 옴 

- Header Checksum : 검사용. 패킷이 송수신되는 과정에서 손상 확인하기 위한 값 

<br/>

### 서브넷 마스크와 CIDR

<span style='color:red'>**192.168.0**</span>.<span style='color:blue'>**10**</span> = 1100 0000 1010 1000 0000 0000 | 0000 1010

- Network ID / Host ID 

- Subnet mask? 1111 1111 1111 1111 1111 1111 | 0000 0000

	- 네트워크 ID와 AND 연산 → 네트워크 ID가 나와 일치한다면, 우리 네트워크로 유입된다 판단 → bit 단위 AND 연산으로 Host는 0으로 만듦 → 마스크 연산

	- 위 예시와 Subnet Mask를 bit 단위 AND 연산 한 결과 = 1100 0000 1010 1000 0000 0000 | 0000 0000 ⇒ 결과적으로, Host가 0으로 클리어됨 

- Net id가 나랑 일치하면 우리 네트워크로 오는거라고 판단 

- mask 연상 : 패킷의 도착지 판단 (나랑 넷 아이디가 같은가) 

- 그럼 넷 아이디가 어디인지 어떻게 알아? 

	- 클래스 → A, B, C → 이제 안써 

<br/>

**CIDR(Classless Inter-Domain Routing): 싸이더**

클래스 없어!

> 192.168.0.10/24

- /24 : 왼쪽부터 24 비트를 Net ID

- 192.168.0.10

	255.255.255.0 

	⇒ 위 두 줄을 한 줄로 간략화 한 것

<br/>

### Broadcast IP 주소

- mac address에서도 다룸 

- mac 주소는 48 비트 주소 체계 (FF-FF-FF-FF-FF..)

> 192.168.0.**255**

	255(Host ID): 1111 1111 = FF → 192.168.0 네트워크에서의 방송 주소

 cf. **multi cast**: 전달 받을 애들을 그룹핑

<br/>

브로드캐스트 : 효율 안좋아 → 도달 범위 통제 해야 함 

네트워크 장비에 부담 증가 = 부하 증가 = 효율 감소 

웬만하면 하지마 

네트워크에서 쓸 수 없는 host id :0, 255, 1(게이트웨이) ⇒ 253개만 쓸 수 있어  

→ 순수 pc의 주소 개수는 약 250개

<br/>

### Host 자신을 가리키는 IP 주소 

**127.0.0.1 (Loop Back Address)**

내가 나에게 접근

- 호스트가 내가 나에게 접속해야만 할 때 

- 접속? 연결? : 주체는 프로세스 

- 인터넷을 사용하는건 인터넷에서 실행 중인 프로세스 

- 프로세스가 컴 내 여러 개 작동 중 

- 프로세스들 간 통신해야 할 때가 있음 

- 내가 나에게 접속

-  구조적으로…

	- 프로세스가 소켓 열고, →TCP→IP→Driver로 외부로 나가지만, loopback에서는 IP에서 다른 프로세스로 향함 

	- 밑으로 패킷 안감 

	- 두 프로세스 간 정보 주고받기용 

	- IPC :Inter Process Communication 구현할 때 루프백

<br/>

### TTL과 단편화 

인터넷은 **라우터의 집합체**라고 할 수 있는 논리 네트워크 

router vs l3 switch 

라우터 : l3 스위치의 일종? 구분하지마? 역관계?

→ 둘을 구분하는게 의미가 없어 

라우터는 개념적으로 l3 스위치에 포함되는게 아닐까..

인터넷 핵심 구성요소: router + dns

라우터: 라우팅, 택배기사 역할

→ 라우터를 거쳐간다.  

TTL: Time To Live

- 텔로미어 같은 역할 

- 패킷은 인터넷에서의 단위, 목적지 가야 하는데 못 가는 경우 

	라우팅 하면서 가다가 못찾았다 → 패킷 없애야 해 

	⇒ TTL 역할

	128, 255 등 값 → 라우터에서 라우터 지날 때 (**Hop**) 1씩 감소시키기

	0이 되면, 라우터가 해당 패킷 갖다 버리기 → 폐기를 알리기도 함 아니기도

<br/>

**단편화** MTU(보통 1500 바이트)

- 1500 / 1400 → 수신 용량 차이 

- 1400에 1500 보내면 패킷 소실

- 1400에 맞춰서 1500을 둘로 쪼개 보낼게  = 단편화

<br/>

라우터는 라우팅 테이블을 보고 라우팅을 한다 (다음 라우터 어디로 가) 

- pc(출발)와 서버(도착)의 mtu는 1500인데 5번 라우터의 mtu가 1400이야!

- 3번이 단편화: [IP | A] [IP | B]

- 3→5 갈 때 패킷 2개 → 서버가 두개를 조립해야 함 (도착지에서) 

- 데이터를 소켓으로 내려보내서 패킷으로 만들어지는데, 

	라우터에서 분해(단편화)가 일어나니까 패킷이 도착할 때 ip 프로토콜 스택에서 조립함 

	완전한 패킷에서 세그먼트를 추출 → TCP에서 조립 → 프로세스에 전달

- 단편화 없는게 베스트 

- 처음부터 1400으로 보내면 단편화 안생기지 

→ mtu가 1500이 안되는 경우?? 

- VPN (IPSec) : mtu 사이즈 줄어듦 

<br/>

### 인터넷 설정 자동화를 위한 DHCP

- 인터넷 사용 전 설정? 

	- host를 식별할 수 있는 식별자 설정

		- ip 주소 : ipv4→32bit 

		- Internet service provider 가 ip 주소 하나 허락해줌

	- subnet mask 

	- gateway ip 주소

	---

	위가 l3

	- dns 주소 : www.naver.com→ ip주소가 뭔지 dns가 알려줌

→ 보통 자동 설정

자동? 

- DHCP를 사용하겠다. 

<br/>

**DHCP(Dynamic Host Configuration Protocol)**

- 인터넷 쓰기 위해서는 인터넷 쓰려는 호스트에 대해 config를 잡아야 함 (ip , gw, dns)

- dhcp를 이용하면, 자동으로 설정됨 

**복잡한 인터넷 설정을 자동으로 해줌, ⇒ 내가 사용할 IP 주소를 서버가 알려줌**

- dynamic = runtime 

- 작동 방식

	- pc가 전원 키면, 네트워크로 브로드캐스트 패킷 나감 (broadcast=우리 네트워크 중에 dhcp 서버가 있어? 라는 트래픽 나감)

	- 모든 곳에 전달함 → dhcp서버가 응답함

	- DHCP 서버: 주소 할당 받은 적 있으면, 그거 계속 써도 되냐고 물어봐

		→ 안되면 새로 할당해줌 

	- ip, gateway, dns, subnet을 서버가 보내줌

	- dhcp서버 내에 ip주소 갖고 있는 pool 있음

	- 브로드캐스트 도메인 안에 묶여있음 → 게이트웨이 너머가 아님 

<br/>

### ARP(<span style='color:red'>Address</span> Resolution Protocol)

address: ip주소, mac주소

- 호스트에서 주소는 ip(L3), mac(L2)! → 쌍을 이루기 마련

- L2 구간에서만 맥 주소 

- IP 주소로 MAC 주소를 알아내려 할 때 활용

	- 언제? 남의 컴 mac을 왜 알아? 

		→ **게이트웨이의 mac 주소** 모르면 인터넷 못써

- 네트워크로 ARP 브로드캐스트 뿌림

	- 우리 네트워크에서 ip 주소가 192.168.0.1인 호스트가 있니? 

	- 게이트웨이가 그 주소 쓰고 있으면, 응답 전송

	- 내 맥 주소도 같이보내줄게~ (게이트웨이) 

	- 네이버에 접속할 때 패킷이 나갈텐데, **목적지 맥 주소**는? 

		- **게이트웨이** 맥주소 

		- 네이버 접속할 때 목적지 맥 주소는 게이트웨이로 잡힌다

		- 게이트웨이는 Ip 패킷 보고 이동

		⇒ 목적지는 게이트웨이 맥 주소, Ip 주소는 네이버의 ip 

	- dhcp 서버가 게이트웨이 맥 주소까지 알려주진 않으니까 arp 브로드캐스트 

- arp로 게이트웨이 맥 주소 알아냈으면 캐시로 메모리에 담고 있어

<br/>

### Ping과 RTT

**Ping**

- 동기화 : 서버 쓰는 게임, 보는 화면이 동일해야 해 

- 서버와의 회선 연결 상태에서…

	Ping: RTT 측정하는 프로그램 이름 

	⇒ ICMP(internet control message protocol): round trip time 시간 측정

	- 회신에 걸리는 시간이 20ms인데, 다른 애는 50, 25

- 네트워크 속도에 따라 RTT 변동

	- 물리적 거리가 멀면 보통 속도는 느려짐

<br/>

### TCP와 UDP 개요

TCP, UDP: L4 Protocol 

- TCP: 연결→ Connection, Session

	- 연결 = 논리적  → virtual circuit

	- internet도 논리… 

- UDP: 연결X

<br/>

- 연결은 결과적으로 **순서번호**로 구현된다. 

	- Segment는 퍼즐 조각에 번호를 붙인 것 → 1번(400 bytes)→401번

- 연결은 상태(전이) 개념을 동반

	- 상태는 전이한다. ex) 전화기 → 연결 전 / 통화 / 연결 종료 후

- TCP: 데이터 보낼 때 수신 측에 여유공간 없으면(Zero window→어플리케이션 수준의 장애) 안보냄

- UDP: 받던지 말던지 난 보낼게 , 무조건 전송 

  

 **식별자 / 데이터 단위**

 | L7 HTTP |  |  | 
 | ---- | ---- | ---- | 
 | L5 SSL |  | Socket+Stream | 
 | L4 TCP, UDP | Port 번호 | Segment(TCP), Datagram(UDP) | 
 | L3 IP | IPv4 주소 | packet | 
 | L2 Ethernet | MAC 주소 | Frame | 

- Stream: 시작은 있는데 끝은 없어 → 소켓 통신을 하는 프로세스가 정하는 어플리케이션 프로토콜 규정에 따르기 때문

	L4 이상은 스트림 데이터를 잘라서 세그먼트로 만들고… 

- Port 번호는 여러 의미를 갖고 있음 

	- L2 : 인터페이스 번호 

	- L4: 서비스 식별자

	- end point server: 프로세스 식별자 

<br/>

< TCP >  Client / Server

- server: 연결 대기 

- client: 프로세스가 소켓 생성해서 오픈 → PID를 갖는 프로세스가 소켓 열면 TCP Port 번호를 운영체제가 부여한다. 

- 드라이버를 통해 아래로 내려가면 L2 스위치→라우터→인터넷→라우터→L2 스위치 로 연결

- 서버에서도 소켓 생성, 오픈 → listen 상태 (연결 대기) → 프로그램이 os에게 80번(port)만 받을게

- TCP 통신 시에는 IP, Port 번호 알아야 연결 시도할 수 있음 

- 연결 대기도 아닌데 client가 server로 연결 시도하면, TCP 레벨에서 연결 받을 애가 없는데? 라고 응답이 간다. os가 자동으로 

<br/>

### TCP 연결 과정 

**3-way handshaking**

- RTT 동안 세그먼트가 오고간다. 

	- IP헤더 | TCP 헤더만 있는 페이로드 없는 세그먼트가 오고 감

- SYN : Syncronization

- client에서 시퀀스 넘버 랜덤 생성 :1000→ SYN(1000)

- 서버가 연결대기하고 있다가 응답 보냄 → SYN(**4000**)+ACK(**1001**) 

- 클라이언트가 받아서 응답 → ACK(4001)

- 시간 차이 → 클라이언트가 연결 시도해서 응답받는 순간 클라이언트는 연결됐다고 생각하지만, 서버는 연결 완료로 판단하지 않음

- RTT에서 한 방향으로 가는 시간이 끝나면 ACK가 올텐데, 이걸 받ㄴ은 시점에 연결됐다고 서버가 판단함. 

- TCP 연결의 실체 = Sequence 번호 교환 + 정책(MSS:Maximum Segment Size) 교환

	- MSS 에 차이가 있으면 더 적은 MSS로 클라이언트, 서버가 통일함

- Client: [SYN_SENT → **ESTABLISHED**]

- Server: [LISTEN→SYN_RCVD→**ESTABLISHED**]

⇒ TCP 연결 = 정책교환(Sequence number + MSS) → 관리 정보 교환의 과정 

<br/>

**연결** : physical한 서킷이 아니라 virtual 서킷 → 연결은 논리적. 실제로 전선을 연결하는게 아니다. 

	→ **virtual  논리적 연결**

	<br/>

### TCP 연결종료 및 상태변화 

**4-way handshaking**

- 특별한 이유 없다면 Client가 Active → 연결 하자고 하는 것, 끊는 것 모두 Client 여야 한다. (보편적)

- 서버가 연결 끊는다면, 특수 경우 

연결 종료는 **(FIN+ACK) + (ACK)** 가 한 세트

- C→S : FIN+ACK : 연결 끊자

- S→C : ACK :그래 끊자~ 

- S→C : FIN + ACK 

	- 이걸 받은 클라이언트는 **TIME_WAIT** 상태가 됨 

	- 클라이언트가 연결을 끊자고 했기 때문에 TIME_WAIT가 발생한 것. 

	- 만약 서버가 연결 종료를 요청했다면 서버에서 TIME_WAIT가 발생함

- C→S: ACK 

- Client 상태변화 : [ESTABLISHED→FIN_WAIT1→FIN_WAIT2→TIME_WAIT→CLOSED]

	- FIN_WAIT1: 서버에서 올 ACK 대기 

	- FIN_WAIT2: 서버에서 올 FIN_WAIT 대기 

	- TIME_WAIT 상태에서 일정 시간 있다가 CLOSED로 넘어감 → 이때 소켓 회수 

		- 소켓: 유한자원, 클라이언트는 소켓의 사용 개수 제한 존재 → 연결 종료하면 소켓 회수해야

- Server 상태변화: [ESTABLISHED→CLOSE_WAIT→LAST_ACK→CLOSED]

	- CLOSE_WAIT: 연결 종료 시퀀스로 돌입 

	- LAST_ACK: 클라이언트에서 올 마지막 ACK를 대기 

서버는 클라이언트에게 연결 종료를 요청하도록 어플리케이션 프로토콜이 설계되어야 함 

- 어플리케이션 프로토콜: L4 수준 .. 

어플리케이션 프로토콜 할 때 클라이언트가 연결 종료하도록 유도해야 서버에서 TIME_WAIT 발생하지 않음

	⇒ TIME_WAIT 발생하면, CLOSED 까지 대기해야 소켓이 회수됨 → 근데 서버에서는 닫아야 할 소켓이 매우 많겠지 → 회수하려면 오랜 시간이 소요됨 → 클라이언트가 연결 종료해주는게 더 좋음

<br/>

### TCP, UDP 헤더 형식과 게임서버 특징 

[ TCP HEADER]

- Source Port | Destination  Port → 각 16 bit $  = 2^{16} $

	Sequence Number 

	Data offset | 상태 | window size

- window size: 여유 공간 → 0이면, 프로그램에서 해결해야 함 → 네트워크 전송 속도가 처리 속도보다 빠름

<br/>

[ UDP HEADER]

- Source Port | Destination Port

	Length | Checksum

혼잡제어 안함, 수신 측 버퍼 상태 고려하지 않음

UDP는 클라이언트 배려하지 않는 프로토콜

- 언제 사용? IPTV (영상 송출)

	- 영상 송출 서버에 연결된 수많은 서비스 이용자 → 속도가 느린 사람에 맞추면 손해 ⇒ 모두 고려하지 않고, 빨리 와장창 보내기

	- TCP 이용해서 동기화하면 하향평준화됨 

		→ UDP로 구현 많이 함

		TCP는 데이터 중간에 하나 못 가면 다시 보내고,.. 

	- TCP 혼잡제어 로직을 만들어서 UDP 사용하기도 해 

- UDP: 멀티미디어에 최적 

<br/>

### TCP ‘연결’이라는 착각

파일 다운로드 중 LAN 케이블 분리했다가 다시 연결하면 TCP 연결은? 

→ 연결 = L4(TCP)에서 연결

→ H/W에서 랜선 뽑아 → 연결 유지됨

- 프로세스에서 연결 되어있는지 지속적으로 재확인 = Heart Beat

	→ ex) 전화통화: 전화가 연결되어 있다고 친구와 나의 대화도 계속 연결되지 않을 수 있음. → 친구가 자버리면? 야 자니?(Heart Beat)

- 연결 = 착각 

- 랜선 뽑았다가 1초만에 다시 꽂기 → 연결 지속 (L4의 논리적 연결 지속)

	- 충격 발생해도, 서비스가 잠깐은 원활히 ..→ 버퍼에 보내놓음

- 무선) 휴대폰의 5G 서비스 → 중개기를 붙었다 떨어지길 반복 → 이 과정이 충격일 것 → 충격이 발생해도 버퍼가 있기 때문에 괜찮음

<br/>

### 한번에 끝내는 DNS

L1~L4 : Infra structure

L5~ : Application을 위해 인프라가 존재 

인터넷을 이루는 서비스 → 대부분 어플리케이션 계층에 존재 

- 인프라에 해당하는 어플리케이션 = **DNS**

<br/>

<span style='color:blue'>**DNS **</span>**Domain Name Service**

→ Naver 접속 시, www.naver.com→ TCP/IP 연결 해야 함 → 네이버 IP 주소 알아? 몰라.. → 누가 알아? → 그걸 아는 데이터베이스가 있어 

- 도메인 네임 = 이름 으로 IPv4 주소 검색해서 결과 알려주는게 DNS

	- www.naver.com →www(네이버에 속한 것) naver(com에 속한 것)

		www $ \in $ naver $ \in $ com

	- domain name :  naver.com 

	- www: host name

	- naver.com 도메인에 속한 이름이 www인 호스트를 찾는 것 

	- **URL** / URI 주소 ⇒ host name+ domain name으로 구성 

	- DNS 서버가 URL에 맞는 주소 알려줌 

- **왜 분산 구조형 데이터베이스?**

	- KT에서 인터넷 회선 사용 중인 사람 → 공유기로 Pc 여러 개 붙어있다 → 주소 창에 https://www.naver.com 검색 → 컴퓨터의 ip 설정에 있는 DNS 서버 주소 → 윈도우 운영체제 내에서 DNS 주소로 질의 전송 [www.naver.com의 ip 주소 알려줘] → DNS가 ip 주소 응답 보내줌 

	- DNS 주소는 ISP에서 정해주는걸 사용 → DNS가 느려지면 인터넷 속도 느려짐 → 알려주는게 느리니까 

	- 만약,  Google DNS(8.8.8.8)를 세팅했다면, DNS로 가는 길이 멀다. → 느려, 내가 사용하는 ISP에 있는 DNS에서 알아오는게 더 빠르지 

	- ip 주소로 접속 가능 

	→ DNS 에게 한 번이라도 Pc가 질의를 하면, www.naver.com의 ip 주소를 메모리에 저장해서 갖고있음 = **DNS Cache**

		display dns 치면 조회 가능 

	→ 응답이 오면(ip주소) 유효 기간이 같이 도착 → 이 주소는 앞으로 두시간 동안만 유지돼~ → 지나면 다시 물어봐줘 

	→ Cache : 계속 물어보면 DNS에 부하 증가 → 똑같은 주소 유효기간 내에 또 검색하면 캐시에서 ip 주소 가져옴

	- 보안) DNS가 거짓말 하면? : 해킹 당하면 큰 일 발생 → 어마어마하게 강력한 보안 적용되어 있음 

	- 1.25 인터넷 대란 : DNS가 다운된 적 → 우리나라 인터넷이 정지됨 

	- DNS Cache: 유효기간 만료될 때 까지 메모리에 상주 

	- hosts 파일 : ip 주소, url → DNS에게 묻지 않아

	- www.naver.com→ 캐시 DNS(Root DNS(13대)→ DNS를 위한 DNS) 누가 주소 물어봤는데 com 시리즈 DNS 알려줘) → DNS ip 목록이 응답으로 도착

		→ 그 중 하나에게 naver라는 애 알아? 질의 → 응 알아~ naver 시리즈 DNS 알려줌 → 그 중에 www라는 애 있어? → ip 주소 반환해줌 

		⇒ 이때 DNS Cache가 url과 ip 주소를 저장해둠

		<br/>

- 트리 구조의 도메인 네임 체계

<br/>

### 웹 기술 창시자와 대한민국 인터넷

- HTML: 문서 

- HTTP: HTML 문서를 실어나르기 위한 프로토콜

<br/>

### URL과 URI 

- Domain Name(naver.com) + Host Name (www)

	URL $ \in $ URI

	- URL: Uniform Resource Locator : 파일이 저장된 위치

	- URI: Uniform Resource Identifire: 식별자

- Resource? : 파일, HTML+CSS+.jpg+js…

- ex) https://<span style='color:red'>**mail.naver.com**</span>/v2/folders/0/all

	- 도메인 네임 →  host 한 대를 특정

	- 그 이후 : 경로 (파일 경로) 

<br/>

### 굵고 짧게 살펴보는 HTTP 

- HTML 문서를 전송받기 위해 만들어진 L7 계층에 속하는 프로토콜 

- 핵심) 헤더 

	- L5 이상이면, 소켓 통신 → 소켓은 Stream 데이터 → 시작은 확실, 끝은 해석 해봐야 함 → 해석하는 규정이 HTTP에 들어있음

	- HTTP 프로토콜은 몽땅 문자열 → 이해하기 쉬움 

	- 요청 / 응답 헤더

		- 요청: Request→ 문서를 요청 

			⇒ 요청하는 방법: GET(달라, 다운로드 개념), POST(업로드 개념, 클라에서 서버로 보낸다는 느낌)

		- 응답 : HTML을 응답해줌 

<br/>

**HTTP 응답 코드**

- 200 OK : 요청 정상 처리  

- 400 Bad request  

- 404 Not found → 클라가 서버에 Resource request (파일달라) → 그런 파일 없는데? 

- 500 Internet server error : 백엔드에 오류가 났다. → SQL 실행에 오류 등 내부 오류 (서버 측 심각한 오류) 

<br/>

**HTTP Method**

- GET: download → 클라이언트가 뭐 달라고 할 때 (파일 달라)

- POST: 업로드 → 파일을 업로드하거나, ID/PWD 도 로그인)

- HEAD : 

- PUT : 리소스 새로 업로드

- DELETE: 삭제 

→ 지우거나, 파일 새로 올리면 문제 될 수도 있어서 거의 안씀

대부분 GET, POST 사용

<br/>

### 그림 한 장으로 외워서 끝내는 웹 서비스 구조 기본 이론

- HTTP 트래픽 : 소켓 수준에서 만들어짐 → Stream 

- 네트워크(TCP/IP)로 뭘 보낼 땐, MTU 1500 따리니까 스트림을 잘라서 segment로 만들어서 packet → 전송 

- http 트래픽은 조각내서 패킷으로 만들어서 전송 

- 웹) 패킷, 세그먼트 논하지 않음, 스트림 수준의 이야기 

	- HTTP: 문자열 → 문서 주세요 / HTML 문서 수신 (하나의 쌍)

<br/>

*Web* 

- 근간 기술) HTML, HTTP (문서, 실어나르기)

	- 웹 서버 앞에 보통 세 개 정도가 있음 : IPS(보안), SSL(가속기), Web 서버를 보호하는 WAF(Web Application Firewall)

		→ IPS : 1차 방어체계, WAF: 2차 방어체계

		- SSL : HTTPS의 S 

	- 웹 클라이언트) 브라우저, 웹 서버 간 TCP/IP 연결 전제 

		- TCP/IP 연결을 기반으로 HTTP 통신이 이루어짐 

		- HTTP가 갖고 있는 특징: State가 없음 (상태개념 없음)

			- 연결은 TCP, HTTP는 그런거 없음 

		- 브라우저의 본질적 역할은 문서 뷰어 → 문서가 웹 서버 어딘가에 저장되어 있는. (HTML 문서 = 리소스) 

		- 주소 검색 → DNS로 IP 찾고 → TCP 연결 → HTTP 통신

		- HTTP 통신 이루어지는 시점에) Request 가 웹 서버에 날라갈텐데, 이때 method가 GET → GET 문서! 문서 주세요! 웹 서버는 리퀘스트 수신하고, 응답

		- 문서 뷰어에 날아오는 HTML 문서를 화면에 표시 (초창기 웹) 

		- 문제) 개발 시 설계 원칙 → 항상 세 개를 구분, 분리해라 = UI / Data(자료구조) / 제어

			- 유지보수 용이하도록

		- 발전..) 문서를 예쁘게 꾸미고 싶어 → 문법 집어넣어 → 문서 그 자체(Data), 꾸미기(UI) → 둘을 섞으면 설계 측면에서 안좋아 

			→ HTML 안에 하나로 하지 않고, 분리하기 위해 생긴게 CSS (Style Sheet)

				HTML 문서 (데이터) + CSS( 꾸미기)

		- 발전..2) 문서는 정적 → 움직임을 넣거나, 내용이 바뀔 수 있는 동적제어 가능한 뭔가 만들고 싶다.  → Java Script: 동적을 반영하기 위한 규칙 스크립트

		- 문서 날아오면 문서 내용을 화면에 렌더링(HTML을) 하기 위해서는 구문 분석부터 해야 함 → txt+tag 를 분리해서 tag에 맞게 렌더링

	- 기본적 구성 요소) 구문분석기 + 렌더링 엔진 + java script 엔진

	- Java Script = 코드 → 웹 서버에 위치함, HTML, CSS, JPG, JS가 날아옴 (서버가 클라에 응답 시)

		⇒ HTTP resposne

<br/>

동적 문서 형태로 발전

- GET: 주세요!(Download) ← HTML 문서 자료를 클라이언트가 달라고 함 → 단방향, 정적

- 로그인: ID, pwd → 로그인 버튼 ⇒ HTTP의 request method → **POST** 양방향 상호작용

	- id, pwd: **원격지 사용자 입력** (서버는 이걸 신뢰하면 안됨 → **검증 대상**)

		⇒ 입력 값에 SQL 문이 있는지 조사 (공격) → 있으면 리젝 

		- DB에서 조사 : DB에 질의 전송 → 웹 서비스 - 중간서버 → DB 

			- 웹 서버는 송/수신 담당(리소스 송수신)

			- DB: 자료 담당, 기억

			- 중간 서버: 처리 즉 연산 담당 → **WAS (Wep Application Server)**

				- Model 개념.. 

				- 컨트롤이라는 제어 체제 → 네트워크 상의 리퀘스트의 제어 체계 

			→ **MVC** 아키텍쳐 

		→ 검증 대상 문자열을 처리 담당 서버에게 보낸다 → 새로운 HTML 문서가 처리 로직에 의해 생성됨 

			클라이언트 측은 결과로 문서 날라옴 (HTML 문서) → 동적인 HTML 문서. 

	- response

	- 모든 방향에 상호작용 되면, 상태 전이가 생김 

		- HTTP는 StateLess → 전이 과정에서 필요한걸 어딘가에 기억시켜야 함 → 클라이언트 쪽, 서버 쪽 모두 구현하게 됨

			⇒ 서버는 기억해야 할게 많음

			- 클라이언트: 쿠키의 형태로 기억 쿠키?(상호작용을 위한 기억의 부산물) → { key, value } 형태로 저장

			- 서버: 기억할게 너무 많으니까 DB로 만들자 

	- 처리 로직에서 DB로 질의 전송 → Found(찾았어!) / 못찾았어(Not Found)

<br/>

### WAS와 RESTful API 그리고 JVM

웹 서버 구성요소) 웹서버 + WAS + DB  (3-Tier) 

<br/>

- 네트워크가 아무리 빨라도 처리 늦어지면 안됨. 처리 빨라도 DB 응답 안하면 느려질 것

	→ DB가 질의 했을 때 응답 보내는데 걸리는 응답 시간 → 서비스 품질 결정에 지대한 영향 

	→ WAS, DB 모니터링해서 웹 어플리케이션 모니터링 = APM (Application Performance Management System) (Scouter)

	→ APM은  DB의 응답시간 모니터링 

- JVM : Java Virtual Machine → Java를 위해 소프트웨어로 구현된 CPU 

	- java byte code로 작동, 이걸 기반으로 어플리케이션 작동시키는걸 Middleware → 소프트웨어, 또 다른 소프트웨어가 잘 작동하도록 도와주는 소프트웨어 

- JSP (Java Server Page) 

- 미들웨어 = WAS

- APM이 JVM도 모니터링 → 서버 관리 

<br/>

<br/>

<br/>

